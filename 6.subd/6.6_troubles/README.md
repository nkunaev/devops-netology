## Задание 1

CRUD — акроним, обозначающий четыре базовые функции, используемые при работе с базами данных: создание (англ. create), чтение (read), модификация (update), удаление (delete)

Соответственно нам нужно удалить подвисший запрос, предварительно уточнив в какой БД работает наш пользователь (разработчик).

Для начала авторизуемся на сервере БД с правами администратора, для этого нам понадобится mongoshell

```commandline
mongosh "mongodb://mongodb0.monain.local:28015" --username root --authenticationDatabase admin
```
Дальше нам надо подключиться к нужной БД

```commandline
use importantDB
```

После чего необходимо найти наш запрос. Это можно сделать 2 путями:
через профайлер, если он настроен на логирование запросов, время исполнения которых превышает определенное значение.
```commandline
db.setProfilingLevel(1)  # устанавливает уровень логирования 0 до 2. Чем число больше, тем больше информации собирается
db.setProfilingLevel(1, { slowms: 50 }) # установим пороговое значение времени в миллисекундах, при котором сведения о запросе буду попадать в лог
db.system.profile.find( { millis : { $gt : 70 } } ).pretty() # показать запросы, которые выполняются дольше 7 сек
db.setProfilingLevel(0) # отключить профайлер
```
или просто запросом, по времени исполнения больше 7 секунд
```commandline
db.currentOp().inprog.forEach(
   function(d){
     if(d.secs_running > 7)
        printjson(d)
})
```

Остается только прервать процесс по его id.

```commandline
db.killOp(shardA:12345)
```

В качестве вариантов решения можно посмотреть в профайлере запросы, которые долго исполняются. Пропустить из через explain 
и посмотреть по каким параметрам чаще всего происходит поиск, после чего проиндексировать. И  отключить своп, если он есть.

```commandline
db.collection.createIndex( { field_name: 1 } )

swapoff и закоментить соттветствуюшую строку в fstab.
```

## Задание 2

В данному случае сработала задержка, вызванная очисткой истекших значений.
В Редисе есть 2 механизма очистки - пассивный и активный. \
Активный режим срабатывает 10 раз в секунду вызывая метод ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP, который удаляет по 20 (значение по умолчанию) 
в каждой итерации. \
Также в Редис встроен механизм, который отслеживает соотношение количества истекших ключей к действующим. 
Если это значение превышает 25%, то Редис может заблокировать запись новых значений до снижения соотношения этого показателя.
Данный механизм разработан, чтобы не использовать слишком много памяти для ключей, срок которых уже истек.

## Задание 3

Если ошибка стала проявляться при увеличении размера БД, то скорее всего сязана с тем, что запросы стали исполняться дольше,
что понятно из текста самой ошибки. Осталось понять, почему запросы стали исполняться дольше.
Для начала, если ситуация критичная, немного бы увеличил параметры БД:
```commandline
SET GLOBAL connect_timeout=60 (до 60 сек, при стандартном знаении в 30) # макс. продолжительность соединения
если не помогло, то возможно причина в превышении размера ответа
SET GLOBAL max_allowed_packet=134217728 (со стандартных 64 Мб до 128, макс - 1 Гб)
```
Когда ситуацию стабилизировали, осталось понять в чем была причина. Я бы диагностировал следующим образом:
* Посмотрел параметры top, iostat, iotop - исключить проблемы с железом, расхода ресурсов и утилизацию
* В самой БД через explain и analyze посмотреть как исполняются запросы, возможно стоит проиндексировать поля или шардировать таблицы
* Если все ок, то возможно проблема в неоптимально составленных запросах
* Также возможно некорректные настройки у самого коннектора на бэкенде

## Задание 4

ООМ-killer завершает процесс когда процесс потребляет слишком много оперативной памяти и
нужно понять, хватает ли в принципе памяти серверу БД.

В качестве решения можно предложить выгружать данные меньшим объемом, т.е. частями.

Также можно снизить вероятность того, что OOM будет прибивать процесс. Для этого необходимо 
произвести некоторые настройки.
```commandline
# Снизить OOM Scrore процесса, чтобы была меньше вероятность, что ООМ прибьет именно БД
sudo echo -100 > /proc/{pid процесса}}/oom_score_adj

# Для хостовой машины изменить параметр резервирования памяти
# чтобы система не резервировала ее слишком много (а потом не жаловалась на ее отсутсвтие)

# режим, при котором резервируется память в размере, не превышающим параметр vm.overcommit_ratio
vm.overcommit_memory=2

# параметр vm.overcommit_ratio выражается в процентах (default 50)
# но может быть и в кб vm.overcommit_kbytes
```
